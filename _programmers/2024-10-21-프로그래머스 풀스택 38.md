---
layout: post
title:  "프로그래머스 풀스택 38"
excerpt: "풀스택38"
category: programmers
tags: [programmers]
date: '2024-10-21 15:00:00 +09:00'
last_modified_at: '2024-10-21'
---

# 프로그래머스 풀스택 38
프론트엔드 기초: React + TypeScript(1)

## 🌊 브라우저와 개발자도구
<span style="color:lightseagreen">💫 **브라우저와 개발자도구**</span><br>

![alt text](img01/image-445.png)<br>
- html 파일은 `!+Tab`을 해주면 자동적으로 기본 형태를 입력해줌<br>

![alt text](img01/image-446.png)<br>
- Windows 기준 `F12`를 통해 개발자 도구를 확인하고, 콘솔도 확인할 수 있음!<br><br>

---
<span style="color:lightseagreen">💫 **브라우저와 디버깅**</span><br>

- **이슈** : 개발 중에 발생하는 예기치 못한 상황<br>
이슈 👉 분석 👉 해결👏<br>
여기서 분석 과정을 **디버깅**이라고 함!<br><br>

- **디버깅** : 개발 중에 발생하는 시스템의 논리적 오류나 비정상적인 연산을 찾아내 원인을 밝히고 수정하는 작업<br><br>
- **디버깅 방법**<br>
    - 의심가는 코드 내에 log 함수 심기<br>
      - `console.log`<br>
      - `console.dir`<br>
      - ...
    - 개발자도구 > Source 탭 활용하기<br>
    브레이킹 포인트를 지정해서 확인하는 방법임!<br><br/>


## 🌊 JavaScript언어의 특징

<span style="color:lightseagreen">💫 **JavaScript언어의 특징 - 인터프리터 언어**</span><br>

✨ **목표** : 기계가 이해해야 함!<br>
✨ **방법** : 개발 언어마다, 처리되는 방식 다름!<br>

🙎🏻**사람이 이해한 언어**로 작성되면<br>
🤖**기계어로 번역**되어야 함!!<br>

1. 컴파일러 언어<br>

    **사람**이 코드를 작성 👉 기계어로 **변환** 👉 기계에서 **실행**<br>

2. 인터프리터(Interpreter) 언어<br>

    **사람**이 코드를 작성 👉 기계에서 **실행** 👉 **변환**하며 진행<br>
    - 컴파일 단계 X<br>
    - 컴파일러 언어에 비해, 실행 속도가 느림<br>
      - 모던 브라우저 내의 V8엔진에서 속도 개선됨<br> 


<br><br> 

---
<span style="color:lightseagreen">💫 **JavaScript언어의 특징 - 그 외**</span><br>

**변수의 타입** : 동적 타입 언어<br>
- 변수에 들어가는 값에 따라서, 런타임에 타입이 추론됨<br>

**함수의 특징** : 일급객체<br>
- 함수는 일급객체의 특징을 가짐<br>
- 함수는 객체와 동일하게 사용가능<br>
- 함수는 값과 동일하게 취급<br>
  - 변수 할당문<br>
  - 객체 프로퍼티 값<br>
  - 배열의 요소<br>
  - 함수 호출의 인수<br>
  - 함수 반환문<br>

**상속의 형태** : 프로토타입 기반의 상속<br>
- 언어가 갖고 있는 프로토타입 체이닝 구조를 통해 **상속**구현<br>

**패러다임 지원** : 함수형 프로그래밍<br>
　　　　　　　명령형 프로그래밍<br>
　　　　　　　객체지향 프로그래밍<br>
　　　　　　　...<br>

<br> <br/>

## 🌊 JavaScript 표준화 - JavaScript의 탄생배경과 ECMAScript


<span style="color:lightseagreen">💫 **JavaScript 표준화 - JavaScript의 탄생배경과 ECMAScript**</span><br>

**자바스크립트의 탄생과 표준화 이유!**<br>
- 자사 소프트웨어의 <U>사용의 점유율을 높이기 위해</U><br>
브라우저마다 동작하는 기능을 경쟁적으로 추가함<br>
    - 즉, 같은 자바스크립트 파일인데 IE에서만 작동하고, Netscape에서는 작동 안하는 현상 발생<br>
    - **크로스 브라우징 이슈**<br><br>
- **모든 브라우저에서 자바스크립트는 동일하게 작동해야 함!!!**<br>
    - 1996년 표준화 개발 진행 (넷스케이프 👉 ECMA 요청)<br>
    - 1997년 ECMA 총회 때 채택<br>
    - 표준화 목록 중 하나 : **ECMA-262**<br>
    - ECMAScript로 명명(ECMAScript 1, ES 1)<br>
- ECMA의 여러 Committee 중 **TC39** Committee가 관리<br>

**따라서 표준화 정책을 고려한 개발이 필요함**<br>
- **언어 버전** 고려하기<br>
- 이를 도와주는 솔루션<br>
  - (트랜스 파일러) Babel<br>
  - (lint) eslint<br>
  - (Bundler) Webpack<br><br>

**ECMAScript와 브라우저**<br>
- 브라우저 버전마다 지원하는 **자바스크립트 스펙이 상이**<br>
  - <U>ECMAScript의 기준을 따라가지 않음</U><br>
  - 개별 기능의 지원 : **Caniuse** 확인가능<br><br>

**브라우저 지원이 안될 경우?**<br>
- polyfill과 babel 사용<br>
- **polyfill**<br>
  - 지원하지 않는 브라우저에서 최신 기능을 제공하기 위해 필요한 **코드**<br>
  - 폴리필은 브라우저가 다른 방식으로 동일한 기능을 구현하는 문제를 해결하는 데 사용<br>
- **Babel**<br>
  - 이전 버전의 브라우저에서 ES6 이전 버전의 자바스크립트로 변환하는 데 사용되는 **도구**<br>
  - 문법을 번역 및 변환<br>
  - 폴리필 가능<br><br/>

## 🌊 변수란?
<span style="color:lightseagreen">💫 **변수란?**</span><br>

**데이터를 처리하기 위해 기억해야 함!**<br>
- 데이터 처리 과정에서 처리 흐름마다 값들을 기억할 필요가 있음<br>
- 컴퓨터는 데이터를 기억하기 위해 메모리를 활용<br>
  - 메모리란? **컴퓨터의 기억장치**<br>
- 메모리<br>
  - 메모리에 데이터를 담아 기억<br>
  - 각각의 위치 주소값이 존재<br>
  - 위치를 찾기 위해서는 메모리의 주소값 사용<br><br>

**메모리의 주소값의 별칭, 변수**<br>
- 메모리 주소값을 대신할 식별자를 지정, 식별자를 통해 데이터 접근<br>
- 식별자 == 변수<br><br>

**변수란,**<br>
`데이터를 담아둔 메모리의 주소를 쉽게 식별하기 위해 붙인 이름`<br><br>

**자바스크립트의 변수 syntax**<br>
- **키워드** let / const/ var <br>
- **변수명**<br>
- **할당 연산자**<br>
- **값**<br><br/>

## 🌊 변수 생성 방법과 호이스팅

<span style="color:lightseagreen">💫 **변수 생성 방법과 호이스팅**</span><br>

**3단계를 거쳐 생성되는 변수**<br>

**평가 단계 + 실행 단계**<br>

1. **선언 단계**<br>
변수를 변수 객체에 등록<br>
2. **초기화 단계**<br>
변수를 메모리에 할당, undefined로 초기화(안하면 접근불가)<br>
3. **할당 단계**<br>
undefined로 초기화된 변수에 실제로 값을 할당<br><br>

---
<span style="color:lightseagreen">💫 **변수 생성 3단계는 키워드별로 다르게 동작함 (var / const, let )**</span><br>


**var 키워드**<br>
- **코드 평가**단계 : 선언과 동시에 초기화 진행<br>
- **코드 실행**단계 : 값 할당 진행<br>
- 코드 평가시점에서 초기화가 되어있으므로,<br>
**변수의 할당문이 실행되기 전에도 참조 가능 👉 (호이스팅)**<br><br>

**var 키워드 - 호이스팅? Hoisting**<br>
- 모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성<br>
- 함수 호이스팅, 변수 호이스팅, ...<br><br>

**var 키워드 - 단점**<br>
- 키워드 생략 가능<br>
- 중복 선언 가능<br>
- 변수 호이스팅(실행 순서와 무관하게 변수가 호이스팅됨)<br><br>

**var 키워드 - 단점 - 전역변수화**<br>
- 전역 변수화 되어, 무분별한 변수 접근<br>
- 스코프 : 코드 실행 중에, 변수와 같은 식별자를 찾아야하는 코드가 있을 때 자바스크립트가 갖고 있는 규칙<br>
    - 전역 스코프(global), 지역 스코프(local)<br>
- 의도치 않은 변수값 변경, 코드 예측이 어려워짐👎<br><br>

그러므로 var의 사용을 지양하고 const/let을 사용하자!<br><br>

---
**const, let 키워드**<br>

- **코드 평가**단계 : 선언 진행<br>
- **코드 실행**단계 : 초기화 진행, 값 할당 진행<br>
- 코드 평가시점에서 선언만 진행되므로, **변수의 할당문이 실행되기 전에 참조 불가능**<br>
  - ReferenceError 발생<br>

- **블록 레벨 스코프**<br>
  - 코드 블록 내에서 접근 가능한 스코프<br>
- 변수에 한정적으로 접근이 가능하므로,<br>
**예측 가능한 범위 내**에서 변수 변경이 일어남<br><br>

- **const키워드**<br>
  - 수정이 불가능한<br>
  "상수 변수"를 선언할 때 사용<br>
  - 무조건 값을 할당<br><br>

- **let키워드**<br>
  - 재할당이 가능한 변수 타입<br>
  - 값을 할당하지 않아도 생성<br>

<br><br/>

## 🌊 로그인 상태가 아니라면 liked 제외

<span style="color:lightseagreen">💫 **로그인 상태가 아니라면 liked 제외**</span><br>

<br><br/>

## 🌊 좋아요 추가, 삭제 로직 response 좋아요 수

<span style="color:lightseagreen">💫 **좋아요 추가, 삭제 로직 response 좋아요 수**</span><br>




<br><br/>

## 🌊 로그인 상태여야 하는 기능들 : 장바구니 도서 삭제, 주문 (상세) 내역 조회

<span style="color:lightseagreen">💫 **로그인 상태여야 하는 기능들 : 장바구니 도서 삭제, 주문 (상세) 내역 조회**</span><br>




<br><br/>

## 🌊 전체 도서 조회 수정

<span style="color:lightseagreen">💫 **전체 도서 조회 pagination 추가**</span><br>

- 현재 몇 개씩, 몇 페이지인지 알려주기가 필요함<br>
- 백엔드와 프론트엔드 둘 다 화면 단에서 몇 페이지인지 저장이 되어 있지 않음!<br>

![alt text](img01/image-437.png)<br><br>

---
<span style="color:lightseagreen">💫 **전체 도서 조회 pagination 구현**</span><br>

```sql
SELECT * FROM Bookshop.books LIMIT 4 OFFSET 0;
SELECT count(*) FROM Bookshop.books;
```
![alt text](img01/image-438.png)<br>
```sql
SELECT sql_calc_found_rows * FROM Bookshop.books LIMIT 4 OFFSET 0;
SELECT found_rows();
```
![alt text](img01/image-439.png)<br>

- 둘 다 같은 값을 출력하지만 아래의 found_rows()를 사용한 sql문이 더 빠름!<br><br>

![alt text](img01/image-440.png)<br>
- let sql = "SELECT * 을 let sql = "SELECT SQL_CALC_FOUND_ROWS * 로 수정해줌<br><br>

\<POSTMAN 결과><br>
![alt text](img01/image-441.png)<br>
- 잘 실행됨!<br><br>

---
<span style="color:lightseagreen">💫 **전체 도서 조회 response body 구성 맞추기**</span><br>

```javascript
    let allBooksRes = {};
    // ... 생략
    sql = "SELECT found_rows()";
    values.push(parseInt(limit), offset);
    conn.query(sql,
        (err, results) => {
            if (err) {
                console.error(err);
                return res.status(StatusCodes.BAD_REQUEST).end();
            }
            let pagination = {};
            pagination.currentPage = parseInt(currentPage);
            pagination.totalCount =results[0]["found_rows()"];
            allBooksRes.pagination = pagination;
            return res.status(StatusCodes.OK).json(allBooksRes);
    })
    // ... 생략
```
![alt text](img01/image-442.png)<br>
- 코드 수정 후 POSTMAN에서 잘 작동하는 모습!<br>
- currentPage를 parseInt(currentPage)해줘서 정수 값으로 나오게 하기<br><br/>

## 🌊 response 포맷 확인하기 (카멜?! 스네이크?!)

<span style="color:lightseagreen">💫 **response 포맷 확인하기 (카멜?! 스네이크?!)**</span><br>


![alt text](img01/image-443.png)<br>
![alt text](img01/image-444.png)<br>
- snake 형식에서 camel로 바꿔주기로 함!<br>
- 자잘한 것들도 수정이 필요한데 대표적으로 두 개만 삽입해둠!<br><br>

---
<span style="color:lightseagreen">💫 **response format 바꿔보기 : snake > camel**</span><br>

컬럼 수정 X 👉 JSON 키값 수정<br>
```javascript
        if(results.length){   
            results.map(function(result) {
                result.pubDate = result.pub_date;
                delete result.pub_date;
            });
```
- 이걸 추가하면 POSTMAN에서  snake 👉 camel로 출력이 가능하게 됨!<br>

<br><br/>

## 🌊 끝날때 까지 끝난 게 아님!!! (feat. 코드 퀄리티)

<span style="color:lightseagreen">💫 **끝날때 까지 끝난 게 아님!!! (feat. 코드 퀄리티)**</span><br>

- **response 포맷 통일(snake 👉 camel), status code ...**<br>

- **데이터베이스 중복 코드 👉 모듈화**<br>
ex. User.Controller 👉 User(데이터 모듈=Model) - CRUD<br>
　　cf. DB 모듈 : mysql 👉 몽구스, 시퀄라이즈<br><br>

- **패키지 구조**<br>
1) **Router : 경로(URI, URL)와 HTTP method로 요청에 따른 경로를 찾아주는 역할**<br>
2) **Controller : 길 매니저- 요청을 환영!! 직접 일을 하진 않음.**<br>
3) Service : 직접 일을 하고 ex. 어떤 쿼리를 부를지,<br>
"비즈니스 로직"<br>
4) **Model : 데이터베이스와 소통 👉 query 집합**<br><br>

- **✨예외처리 (try/catch) 더 해줄 곳 찾기**<br>
- **유효성 검사 추가**<br>
- **jwt(심화) : access token이 만료되면, '로그인 연장?'**<br>
**로그인 시 access token(30m) refresh token(24h)**<br>
　　1) access token : 로그인한 사람이야 인증(만들어본 것)<br>
　　2) refresh token: 로그인 연장하는 용도<br>

- 랜덤 데이터 (외부) API를 활용해서 ISBN 샘플 데이터 채워보기<br>
- nodemon 모듈 : 업데이트가 있을 때마다 자동 실행해주는 모듈<br><br/>

## 🌊 느낀 점(YWT)

**Y 일을 통해 명확히 알게 되었거나 이해한 부분(한 일)에 대해 정리 :**<br>
코드의 고도화!<br>

**W 배운 점과 시사점 :**<br>
- **response 포맷 통일(snake 👉 camel), status code ...**<br>
- 예외처리와 유효성 검사, jwt 심화를 통해 코드 고도화를 해주는 걸 잊지 말기!<br>

<br>

**T 응용하여 배운 것을 어디에 어떻게 적용할지:**<br>
API와 코드를 일치하는 작업과 고도화를 통해 백엔드와 프론트엔드 사이의 작업이 원할하게 가능함!<br>